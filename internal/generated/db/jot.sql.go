// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: jot.sql

package db

import (
	"context"
	"time"
)

const createJot = `-- name: CreateJot :one
insert into
  jot (content, tag_id)
values
  (?1, ?2) returning id, content, created_at, updated_at, pinned, deleted, tag_id
`

type CreateJotParams struct {
	Content string `json:"content"`
	TagID   int64  `json:"tagId"`
}

func (q *Queries) CreateJot(ctx context.Context, arg CreateJotParams) (Jot, error) {
	row := q.db.QueryRowContext(ctx, createJot, arg.Content, arg.TagID)
	var i Jot
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Pinned,
		&i.Deleted,
		&i.TagID,
	)
	return i, err
}

const getJotById = `-- name: GetJotById :one
;

select
  j.id,
  j.created_at,
  j.updated_at,
  j.content,
  j.pinned,
  j.deleted,
  t.id, t.name
from
  jot j
  inner join tag t on j.tag_id = t.id
where
  j.id = ?1
`

type GetJotByIdRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	Content   string    `json:"content"`
	Pinned    bool      `json:"pinned"`
	Deleted   bool      `json:"deleted"`
	Tag       Tag       `json:"tag"`
}

func (q *Queries) GetJotById(ctx context.Context, id int64) (GetJotByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getJotById, id)
	var i GetJotByIdRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Content,
		&i.Pinned,
		&i.Deleted,
		&i.Tag.ID,
		&i.Tag.Name,
	)
	return i, err
}

const listJots = `-- name: ListJots :many
;

select
  j.id,
  j.created_at,
  j.updated_at,
  j.content,
  j.pinned,
  j.deleted,
  t.id, t.name
from
  jot j
  left join tag t on j.tag_id = t.id
where
  j.deleted = false
  and (
    ?1 is null
    or j.content glob concat ('*', ?1, '*')
    or t.name glob concat ('*', ?1, '*')
  )
order by
  j.pinned desc,
  j.created_at desc
limit
  ?3
offset
  ?2
`

type ListJotsParams struct {
	SearchTerm interface{} `json:"searchTerm"`
	Offset     int64       `json:"offset"`
	Limit      int64       `json:"limit"`
}

type ListJotsRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	Content   string    `json:"content"`
	Pinned    bool      `json:"pinned"`
	Deleted   bool      `json:"deleted"`
	Tag       Tag       `json:"tag"`
}

func (q *Queries) ListJots(ctx context.Context, arg ListJotsParams) ([]ListJotsRow, error) {
	rows, err := q.db.QueryContext(ctx, listJots, arg.SearchTerm, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListJotsRow{}
	for rows.Next() {
		var i ListJotsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Content,
			&i.Pinned,
			&i.Deleted,
			&i.Tag.ID,
			&i.Tag.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJot = `-- name: UpdateJot :one
;

update jot
set
  pinned = ?1,
  deleted = ?2,
  updated_at = current_timestamp
where
  id = ?3 returning id, content, created_at, updated_at, pinned, deleted, tag_id
`

type UpdateJotParams struct {
	Pinned  bool  `json:"pinned"`
	Deleted bool  `json:"deleted"`
	ID      int64 `json:"id"`
}

func (q *Queries) UpdateJot(ctx context.Context, arg UpdateJotParams) (Jot, error) {
	row := q.db.QueryRowContext(ctx, updateJot, arg.Pinned, arg.Deleted, arg.ID)
	var i Jot
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Pinned,
		&i.Deleted,
		&i.TagID,
	)
	return i, err
}
